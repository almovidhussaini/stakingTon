;; #include "imports/stdlib.fc"

;; Error codes
const int insufficient_balance = 101;
const int no_staked_tokens = 102;

() mint_reward(slice recipient_address, int reward_amount, slice admin_address, int msg_value) impure {
  ;; Ensure this function is called by the admin
  throw_unless(73, equal_slices(my_address(), admin_address));

  ;; Construct the mint operation message
  var mint_message = begin_cell()
      .store_uint(op::mint(), 32)      ;; Opcode for mint operation
      .store_uint(now(), 64)           ;; Query ID (use the current timestamp for uniqueness)
      .store_slice(recipient_address)  ;; Address of the recipient
      .store_coins(reward_amount)      ;; Amount of tokens to mint
      .store_ref(begin_cell()          ;; Master message (custom payload)
          .store_uint(op::transfer(), 32)
          .store_uint(now(), 64)
          .store_coins(reward_amount)
          .store_slice(recipient_address)
          .end_cell()
      )
      .end_cell();

  ;; Send the mint message to the master wallet
  send_raw_message(mint_message, msg_value);
}


;; Staking Contract
() stake_tokens(int stake_amount, slice sender_address) impure {
    ;; Check if sender has sufficient balance
    int sender_balance = get_balance(sender_address);
    throw_unless(sender_balance >= stake_amount, insufficient_balance);

    ;; Transfer the stake_amount to the staking contract
    slice contract_address = my_address(); ;; This is the contract's own address
    transfer(sender_address,contract_address, stake_amount);

    ;; Store the staked amount
    (int current_staked_amount, int staking_time) = load_staked_data(sender_address);
    save_staked_data(sender_address, current_staked_amount + stake_amount, current_time());

    return ();
}
() withdraw(int amount_withdraw, slice sender_address) impure {
    (int current_staked_amount, int staking_time) = load_staked_data(sender_address);
    throw_unless(current_staked_amount >= amount_withdraw, insufficient_balance);

    save_staked_data(sender_address,current_staked_amount-amount_withdraw,staking_time);
    send_coins(sender_address, amount_withdraw);

}

;; Claim Rewards
() claim_rewards(slice sender_address) impure {
    ;; Check if user has staked tokens
    (int staked_amount, int staking_time) = load_staked_data(sender_address);
    throw_unless(staked_amount > 0, no_staked_tokens);

    ;; Calculate rewards based on staked amount and staking duration
    int staking_duration = current_time() - staking_time;
    int reward_amount = calculate_rewards(staked_amount, staking_duration);

    ;; Reset staking details after reward claim
    save_staked_data(sender_address, 0, 0); 

    var master_message = begin_cell()
        .store_uint(op::reward_metadata(), 32)  ;; Custom opcode for reward metadata
        .store_uint(now(), 64)                  ;; Query ID
        .store_coins(reward_amount)             ;; Reward amount for reference
        .store_slice(sender_address)            ;; Receiver's address
        .end_cell();

    mint_tokens(sender_address, jetton_wallet_code, reward_amount, master_message);

    return ();
}

;; Helper function to calculate rewards (example: 1% daily reward rate)
int calculate_rewards(int staked_amount, int staking_duration) inline {
    int reward_rate_per_day = 1; ;; 1% daily reward
    int duration_in_days = staking_duration / 86400; ;; Convert seconds to days
    return muldiv(staked_amount, reward_rate_per_day * duration_in_days, 100);
}

;; Load and Save Staked Data (Staked Amount + Staking Time)
(int, int) load_staked_data(slice address) impure {
    ;; Get the stored cell
    cell stored_data = get_data(address);
    if (stored_data == null()) {
    return (0, 0); ;; No staked data
}
    slice ds = stored_data.begin_parse();
    int staked_amount = ds~load_coins();
    int staking_time = ds~load_uint(64);
    return (staked_amount, staking_time);
}

() save_staked_data(slice address, int staked_amount, int staking_time) impure {
    ;; Serialize the staked data into a cell
    cell staked_data = begin_cell()
        .store_coins(staked_amount)
        .store_uint(staking_time, 64)
        .end_cell();
    set_data(address, staked_data);
}

;; Transfer Helper Function
() transfer(slice sender_address,slice recipient_address, int amount) impure {
    ;; Transfer tokens to the specified address
    send_coins(sender_address, recipient_address, amount);
}

;; Time Helper
int current_time() impure {
    ;; Return the current block timestamp (implementation-specific)
    return get_time();
}
