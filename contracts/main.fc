;; #include "imports/stdlib.fc"

;; Error codes
const int insufficient_balance = 101;
const int no_staked_tokens = 102;

() mint_reward(slice user_address, int reward_amount,slice jetton_minter_address) impure {
    ;; Jetton Minter address
    ;; slice jetton_minter_address = "your_jetton_minter_address_here".begin_parse();

    ;; Query ID for the mint operation (can be any unique value)
    int query_id = now();

    ;; Construct the payload for the mint operation
    var mint_payload = begin_cell()
        .store_uint(op::mint(), 32)          ;; Operation code for `mint`
        .store_uint(query_id, 64)           ;; Unique query ID
        .store_slice(user_address)          ;; Recipient's wallet address
        .store_coins(reward_amount)         ;; Amount of tokens to mint
        .store_ref(empty_cell())            ;; Optional metadata (can be replaced with actual data)
        .end_cell();

    ;; Construct the internal message
    var msg = begin_cell()
        .store_uint(0x10, 6)                ;; Internal message flags
        .store_slice(jetton_minter_address) ;; Target: Jetton Minter address
        .store_coins(0)                     ;; Value sent (ensure Minter has enough gas to process)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1) ;; Flags and gas values
        .store_ref(mint_payload)            ;; Attach the mint payload
        .end_cell();

    ;; Send the message to the Jetton Minter
    send_raw_message(msg, 1);
}



;; Staking Contract
() stake_tokens(int stake_amount, slice sender_address) impure {
    ;; Check if sender has sufficient balance
    int sender_balance = get_balance(sender_address);
    throw_unless(sender_balance >= stake_amount, insufficient_balance);

    ;; Transfer the stake_amount to the staking contract
    slice contract_address = my_address(); ;; This is the contract's own address
    transfer(sender_address,contract_address, stake_amount);

    ;; Store the staked amount
    (int current_staked_amount, int staking_time) = load_staked_data(sender_address);
    save_staked_data(sender_address, current_staked_amount + stake_amount, current_time());

    return ();
}
() withdraw(int amount_withdraw, slice sender_address) impure {
    (int current_staked_amount, int staking_time) = load_staked_data(sender_address);
    throw_unless(current_staked_amount >= amount_withdraw, insufficient_balance);

    save_staked_data(sender_address,current_staked_amount-amount_withdraw,staking_time);
    send_coins(sender_address, amount_withdraw);

}

;; Claim Rewards
() claim_rewards(slice sender_address) impure {
    ;; Check if user has staked tokens
    (int staked_amount, int staking_time) = load_staked_data(sender_address);
    throw_unless(staked_amount > 0, no_staked_tokens);

    ;; Calculate rewards based on staked amount and staking duration
    int staking_duration = current_time() - staking_time;
    int reward_amount = calculate_rewards(staked_amount, staking_duration);

    mint_reward(sender_address, reward_amount)

    ;; Reset staking details after reward claim
    save_staked_data(sender_address, 0, 0); 

    return ();
}

;; Helper function to calculate rewards (example: 1% daily reward rate)
int calculate_rewards(int staked_amount, int staking_duration) inline {
    int reward_rate_per_day = 1; ;; 1% daily reward
    int duration_in_days = staking_duration / 86400; ;; Convert seconds to days
    return muldiv(staked_amount, reward_rate_per_day * duration_in_days, 100);
}

;; Load and Save Staked Data (Staked Amount + Staking Time)
(int, int) load_staked_data(slice address) impure {
    ;; Get the stored cell
    cell stored_data = get_data(address);
    if (stored_data == null()) {
    return (0, 0); ;; No staked data
}
    slice ds = stored_data.begin_parse();
    int staked_amount = ds~load_coins();
    int staking_time = ds~load_uint(64);
    return (staked_amount, staking_time);
}

() save_staked_data(slice address, int staked_amount, int staking_time) impure {
    ;; Serialize the staked data into a cell
    cell staked_data = begin_cell()
        .store_coins(staked_amount)
        .store_uint(staking_time, 64)
        .end_cell();
    set_data(address, staked_data);
}

;; Transfer Helper Function
() transfer(slice sender_address,slice recipient_address, int amount) impure {
    ;; Transfer tokens to the specified address
    send_coins(sender_address, recipient_address, amount);
}

;; Time Helper
int current_time() impure {
    ;; Return the current block timestamp (implementation-specific)
    return get_time();
}
